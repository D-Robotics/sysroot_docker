<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Portable Runtime: Base64/Base64Url/Base32/Base32Hex/Base16 Encoding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Portable Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Base64/Base64Url/Base32/Base32Hex/Base16 Encoding</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae1b2f8cdc66116b6187aafeeba7fd21a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gae1b2f8cdc66116b6187aafeeba7fd21a">APR_ENCODE_STRING</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:gae1b2f8cdc66116b6187aafeeba7fd21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad010d241d416e35583e4b2cd5b5fd0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga9ad010d241d416e35583e4b2cd5b5fd0">APR_ENCODE_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga9ad010d241d416e35583e4b2cd5b5fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4393e3c11c929beff53f850b63b194c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga4393e3c11c929beff53f850b63b194c6">APR_ENCODE_RELAXED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga4393e3c11c929beff53f850b63b194c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab70e2620bff41c57889baab303da126a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gab70e2620bff41c57889baab303da126a">APR_ENCODE_NOPADDING</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gab70e2620bff41c57889baab303da126a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89063c45b8646e859a887ea37558bebb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga89063c45b8646e859a887ea37558bebb">APR_ENCODE_URL</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ga89063c45b8646e859a887ea37558bebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddcfd5acc39eee65ac6bf3c99b384903"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gaddcfd5acc39eee65ac6bf3c99b384903">APR_ENCODE_BASE64URL</a>&#160;&#160;&#160;(<a class="el" href="group___a_p_r___util___encode.html#gab70e2620bff41c57889baab303da126a">APR_ENCODE_NOPADDING</a> | <a class="el" href="group___a_p_r___util___encode.html#ga89063c45b8646e859a887ea37558bebb">APR_ENCODE_URL</a>)</td></tr>
<tr class="separator:gaddcfd5acc39eee65ac6bf3c99b384903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d1ef755cf5f1aa00317949874316db1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga1d1ef755cf5f1aa00317949874316db1">APR_ENCODE_BASE32HEX</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga1d1ef755cf5f1aa00317949874316db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252c4e7a4e77e82d8873fea5a36ac449"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga252c4e7a4e77e82d8873fea5a36ac449">APR_ENCODE_COLON</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ga252c4e7a4e77e82d8873fea5a36ac449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga837652016c99bcf67979e026b34d4b83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga837652016c99bcf67979e026b34d4b83">APR_ENCODE_LOWER</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ga837652016c99bcf67979e026b34d4b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga22d00775eef21b4d782a92b0bcf1e156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga22d00775eef21b4d782a92b0bcf1e156">apr_encode_base64</a> (char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga22d00775eef21b4d782a92b0bcf1e156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1369e67e0d295a40f9d0c212fe5dafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gae1369e67e0d295a40f9d0c212fe5dafb">apr_encode_base64_binary</a> (char *dest, const unsigned char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:gae1369e67e0d295a40f9d0c212fe5dafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20cb2845739baa15c584977dfa58b154"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga20cb2845739baa15c584977dfa58b154">apr_pencode_base64</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga20cb2845739baa15c584977dfa58b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfce66ef543bc712e59319c78b743f4f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gabfce66ef543bc712e59319c78b743f4f">apr_pencode_base64_binary</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const unsigned char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:gabfce66ef543bc712e59319c78b743f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935489e36b9999b0de6f7b9aa6edba7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga935489e36b9999b0de6f7b9aa6edba7b">apr_decode_base64</a> (char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga935489e36b9999b0de6f7b9aa6edba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f2e8328526901d83d20179947593cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga86f2e8328526901d83d20179947593cb">apr_decode_base64_binary</a> (unsigned char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga86f2e8328526901d83d20179947593cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459a9a40c7bd9bba743ce0b3d456f18c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga459a9a40c7bd9bba743ce0b3d456f18c">apr_pdecode_base64</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga459a9a40c7bd9bba743ce0b3d456f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124935cfdf610e8f3cd0d43a91ff7254"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga124935cfdf610e8f3cd0d43a91ff7254">apr_pdecode_base64_binary</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga124935cfdf610e8f3cd0d43a91ff7254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf904301864c7b6d809929f3689d18a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gaf904301864c7b6d809929f3689d18a68">apr_encode_base32</a> (char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:gaf904301864c7b6d809929f3689d18a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f6e11140367fade452e64975f32f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga29f6e11140367fade452e64975f32f07">apr_encode_base32_binary</a> (char *dest, const unsigned char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga29f6e11140367fade452e64975f32f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2784fb3d74d2d82588b39c2b6a275a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga8c2784fb3d74d2d82588b39c2b6a275a">apr_pencode_base32</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga8c2784fb3d74d2d82588b39c2b6a275a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4780933a14779c4eb46e100b0c8e941"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gac4780933a14779c4eb46e100b0c8e941">apr_pencode_base32_binary</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const unsigned char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:gac4780933a14779c4eb46e100b0c8e941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32580a42bda59e33962d0cabb4a6cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gac32580a42bda59e33962d0cabb4a6cc4">apr_decode_base32</a> (char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:gac32580a42bda59e33962d0cabb4a6cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1d18eff68a4fc6992df7a7e29908f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gaaf1d18eff68a4fc6992df7a7e29908f7">apr_decode_base32_binary</a> (unsigned char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:gaaf1d18eff68a4fc6992df7a7e29908f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de3aef884906d1c2b36449c48dab90e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga7de3aef884906d1c2b36449c48dab90e">apr_pdecode_base32</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga7de3aef884906d1c2b36449c48dab90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ca695d97a11934e7fbc7c7f6dd8373"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga23ca695d97a11934e7fbc7c7f6dd8373">apr_pdecode_base32_binary</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga23ca695d97a11934e7fbc7c7f6dd8373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae757c965f9a9a4231bff62194b537d9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gae757c965f9a9a4231bff62194b537d9f">apr_encode_base16</a> (char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:gae757c965f9a9a4231bff62194b537d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6009d6dd6c7ed9a185689fe66f4e7660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga6009d6dd6c7ed9a185689fe66f4e7660">apr_encode_base16_binary</a> (char *dest, const unsigned char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga6009d6dd6c7ed9a185689fe66f4e7660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eead158a297b072d956e79e4d33977f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga1eead158a297b072d956e79e4d33977f">apr_pencode_base16</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga1eead158a297b072d956e79e4d33977f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ade6a0297757acd117fe20d0e8a4a5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga10ade6a0297757acd117fe20d0e8a4a5">apr_pencode_base16_binary</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const unsigned char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga10ade6a0297757acd117fe20d0e8a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0260f05a7fb5d324ee1504c33446f5a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga0260f05a7fb5d324ee1504c33446f5a0">apr_decode_base16</a> (char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga0260f05a7fb5d324ee1504c33446f5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f33b5d0fbf8d9a8c0d304946f671a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga2f33b5d0fbf8d9a8c0d304946f671a62">apr_decode_base16_binary</a> (unsigned char *dest, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga2f33b5d0fbf8d9a8c0d304946f671a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6525de2c6a1398af18a918cfe686e401"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#ga6525de2c6a1398af18a918cfe686e401">apr_pdecode_base16</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:ga6525de2c6a1398af18a918cfe686e401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2388ef96733d95fd02b673bfe32d82"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___encode.html#gabf2388ef96733d95fd02b673bfe32d82">apr_pdecode_base16_binary</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *src, apr_ssize_t slen, int flags, apr_size_t *len)</td></tr>
<tr class="separator:gabf2388ef96733d95fd02b673bfe32d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1d1ef755cf5f1aa00317949874316db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d1ef755cf5f1aa00317949874316db1">&#9670;&nbsp;</a></span>APR_ENCODE_BASE32HEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_BASE32HEX&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate base32hex encoding instead of base32 encoding </p>

</div>
</div>
<a id="gaddcfd5acc39eee65ac6bf3c99b384903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddcfd5acc39eee65ac6bf3c99b384903">&#9670;&nbsp;</a></span>APR_ENCODE_BASE64URL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_BASE64URL&#160;&#160;&#160;(<a class="el" href="group___a_p_r___util___encode.html#gab70e2620bff41c57889baab303da126a">APR_ENCODE_NOPADDING</a> | <a class="el" href="group___a_p_r___util___encode.html#ga89063c45b8646e859a887ea37558bebb">APR_ENCODE_URL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate RFC7515 BASE64URL </p>

</div>
</div>
<a id="ga252c4e7a4e77e82d8873fea5a36ac449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga252c4e7a4e77e82d8873fea5a36ac449">&#9670;&nbsp;</a></span>APR_ENCODE_COLON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_COLON&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate base16 with colons between each token. </p>

</div>
</div>
<a id="ga837652016c99bcf67979e026b34d4b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga837652016c99bcf67979e026b34d4b83">&#9670;&nbsp;</a></span>APR_ENCODE_LOWER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_LOWER&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate base16 with lower case characters. </p>

</div>
</div>
<a id="ga9ad010d241d416e35583e4b2cd5b5fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ad010d241d416e35583e4b2cd5b5fd0">&#9670;&nbsp;</a></span>APR_ENCODE_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_NONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate RFC4648 base16/base32/base64. </p>

</div>
</div>
<a id="gab70e2620bff41c57889baab303da126a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab70e2620bff41c57889baab303da126a">&#9670;&nbsp;</a></span>APR_ENCODE_NOPADDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_NOPADDING&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Omit the padding character (=) while encoding. </p>

</div>
</div>
<a id="ga4393e3c11c929beff53f850b63b194c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4393e3c11c929beff53f850b63b194c6">&#9670;&nbsp;</a></span>APR_ENCODE_RELAXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_RELAXED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If relaxed, decode up until the first non base16/base32/base64 character. </p>

</div>
</div>
<a id="gae1b2f8cdc66116b6187aafeeba7fd21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1b2f8cdc66116b6187aafeeba7fd21a">&#9670;&nbsp;</a></span>APR_ENCODE_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_STRING&#160;&#160;&#160;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RFC4648 and RFC7515 compliant BASE64, BASE64URL, BASE32, BASE32HEX and BASE16 encode/decode functions.</p>
<p>The following encodings are supported:</p>
<ul>
<li><p class="startli">Base 64 Encoding</p>
<p class="startli">o Use flag APR_ENCODE_NONE o <a href="https://tools.ietf.org/html/rfc4648#section-4">https://tools.ietf.org/html/rfc4648#section-4</a></p>
</li>
<li><p class="startli">Base 64 Encoding with URL and Filename Safe Alphabet</p>
<p class="startli">o Use flag APR_ENCODE_URL o <a href="https://tools.ietf.org/html/rfc4648#section-5">https://tools.ietf.org/html/rfc4648#section-5</a></p>
</li>
<li><p class="startli">Base 64 URL Encoding without Padding</p>
<p class="startli">o Use flag APR_ENCODE_BASE64URL o <a href="https://tools.ietf.org/html/rfc7515#appendix-C">https://tools.ietf.org/html/rfc7515#appendix-C</a></p>
</li>
<li><p class="startli">Base 32 Encoding</p>
<p class="startli">o Use flag APR_ENCODE_NONE o <a href="https://tools.ietf.org/html/rfc4648#section-6">https://tools.ietf.org/html/rfc4648#section-6</a></p>
</li>
<li><p class="startli">Base 32 Encoding with Extended Hex Alphabet</p>
<p class="startli">o Use flag APR_ENCODE_BASE32HEX o <a href="https://tools.ietf.org/html/rfc4648#section-7">https://tools.ietf.org/html/rfc4648#section-7</a></p>
</li>
<li><p class="startli">Base 16 Encoding</p>
<p class="startli">o Use flags APR_ENCODE_NONE/APR_ENCODE_COLON o <a href="https://tools.ietf.org/html/rfc4648#section-8">https://tools.ietf.org/html/rfc4648#section-8</a></p>
</li>
</ul>
<p>If a non valid character of any kind including whitespace is passed to any of the decoder functions, APR_BADCH will be returned. In this case decoding will still take place, but the results can not be trusted.</p>
<p>If APR_ENCODE_RELAXED is passed to the decoder functions, decoding will be attempted up until the first non valid character. If this results in an invalid state in the decoder, such as but not limited to an odd number of base16 characters, APR_BADCH will still be returned.</p>
<p>If APR_ENCODE_RELAXED is not passed to a decoder function, the decoding will be done in constant time regardless of whether the result returns APR_SUCCESS or APR_BADCH.</p>
<p>If the dest parameter is NULL, the maximum theoretical buffer size is returned in the len field, including space for a terminating zero character if the destination is a string. This value can be used to allocate buffers of a suitable safe size.</p>
<p>If the dest parameter is provided, the encoding or decoding will take place, and the actual number of characters written is returned in the len field, ignoring any terminating zero.</p>
<p>Plain strings are not assumed '\0' terminated unless APR_ENCODE_STRING is provided. When passing a string to one of the encode functions, this value can be passed to indicate a string-valued key, and have the length computed automatically. </p>

</div>
</div>
<a id="ga89063c45b8646e859a887ea37558bebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89063c45b8646e859a887ea37558bebb">&#9670;&nbsp;</a></span>APR_ENCODE_URL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ENCODE_URL&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate RFC4648 Base 64 Encoding with URL and Filename Safe Alphabet </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0260f05a7fb5d324ee1504c33446f5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0260f05a7fb5d324ee1504c33446f5a0">&#9670;&nbsp;</a></span>apr_decode_base16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_decode_base16 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base16 (hex) to text data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for decoding. </td></tr>
    <tr><td class="paramname">src</td><td>The base16 string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the base16 string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, parse RFC4648 Base 16 Encoding. If APR_ENCODE_COLON, allow tokens to be separated with a colon. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for decoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the decoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to decode, or APR_EINCOMPLETE if the source length (based on <code>slen</code> or APR_ENCODE_STRING) is invalid for a base16 encoding, or APR_BADCH if a non base16 character is present and APR_ENCODE_RELAXED is not specified. </dd></dl>

</div>
</div>
<a id="ga2f33b5d0fbf8d9a8c0d304946f671a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f33b5d0fbf8d9a8c0d304946f671a62">&#9670;&nbsp;</a></span>apr_decode_base16_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_decode_base16_binary </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base16 (hex) to binary data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for decoding. </td></tr>
    <tr><td class="paramname">src</td><td>The base16 string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the base16 string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, parse RFC4648 Base 16 Encoding. If APR_ENCODE_COLON, allow tokens to be separated with a colon. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for decoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the decoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to decode, or APR_EINCOMPLETE if the source length (based on <code>slen</code> or APR_ENCODE_STRING) is invalid for a base16 encoding, or APR_BADCH if a non base16 character is present and APR_ENCODE_RELAXED is not specified. </dd></dl>

</div>
</div>
<a id="gac32580a42bda59e33962d0cabb4a6cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32580a42bda59e33962d0cabb4a6cc4">&#9670;&nbsp;</a></span>apr_decode_base32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_decode_base32 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base32 or base32hex with or without padding to text data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for decoding. </td></tr>
    <tr><td class="paramname">src</td><td>The base32 string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the base32 string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, parse RFC4648 Base 32 Encoding. If APR_ENCODE_BASE32HEX, use RFC4648 base32hex Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for decoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the decoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to decode, or APR_EINCOMPLETE if the source length (based on <code>slen</code> or APR_ENCODE_STRING) is invalid for a base32 encoding, or APR_BADCH if a non base32 character is present and APR_ENCODE_RELAXED is not specified. </dd></dl>

</div>
</div>
<a id="gaaf1d18eff68a4fc6992df7a7e29908f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1d18eff68a4fc6992df7a7e29908f7">&#9670;&nbsp;</a></span>apr_decode_base32_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_decode_base32_binary </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base32 or base32hex with or without padding to binary data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for decoding. </td></tr>
    <tr><td class="paramname">src</td><td>The base32 string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the base32 string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, parse RFC4648 Base 32 Encoding. If APR_ENCODE_BASE32HEX, use RFC4648 base32hex Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for decoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the decoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to decode, or APR_EINCOMPLETE if the source length (based on <code>slen</code> or APR_ENCODE_STRING) is invalid for a base32 encoding, or APR_BADCH if a non base32 character is present and APR_ENCODE_RELAXED is not specified. </dd></dl>

</div>
</div>
<a id="ga935489e36b9999b0de6f7b9aa6edba7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga935489e36b9999b0de6f7b9aa6edba7b">&#9670;&nbsp;</a></span>apr_decode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_decode_base64 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base64 or base64url with or without padding to text data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for decoding. </td></tr>
    <tr><td class="paramname">src</td><td>The base64 string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the base64 string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, attempt to decode the full base64 string, and return NULL if any bad character is detected. If APR_ENCODE_RELAXED, decode until the first non base64/base64url character. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for decoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the decoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to decode, or APR_EINCOMPLETE if the source length (based on <code>slen</code> or APR_ENCODE_STRING) is invalid for a base64 encoding, or APR_BADCH if a non base64 character is present and APR_ENCODE_RELAXED is not specified. </dd></dl>

</div>
</div>
<a id="ga86f2e8328526901d83d20179947593cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86f2e8328526901d83d20179947593cb">&#9670;&nbsp;</a></span>apr_decode_base64_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_decode_base64_binary </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base64 or base64url with or without padding to binary data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for decoding. </td></tr>
    <tr><td class="paramname">src</td><td>The base64 string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the base64 string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, attempt to decode the full base64 string, and return NULL if any bad character is detected. If APR_ENCODE_RELAXED, decode until the first non base64/base64url character. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for decoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the decoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to decode, or APR_EINCOMPLETE if the source length (based on <code>slen</code> or APR_ENCODE_STRING) is invalid for a base64 encoding, or APR_BADCH if a non base64 character is present and APR_ENCODE_RELAXED is not specified. </dd></dl>

</div>
</div>
<a id="gae757c965f9a9a4231bff62194b537d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae757c965f9a9a4231bff62194b537d9f">&#9670;&nbsp;</a></span>apr_encode_base16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_encode_base16 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert text data to base16 (hex). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for encoding. </td></tr>
    <tr><td class="paramname">src</td><td>The original string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 16 Encoding. If APR_ENCODE_COLON, separate each token with a colon. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for encoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the encoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to encode. </dd></dl>

</div>
</div>
<a id="ga6009d6dd6c7ed9a185689fe66f4e7660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6009d6dd6c7ed9a185689fe66f4e7660">&#9670;&nbsp;</a></span>apr_encode_base16_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_encode_base16_binary </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert binary data to base16 (hex). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for encoding. </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer, can be NULL if <code>dest</code> is NULL. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 16 Encoding. If APR_ENCODE_COLON, separate each token with a colon. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for encoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the encoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to encode. </dd></dl>

</div>
</div>
<a id="gaf904301864c7b6d809929f3689d18a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf904301864c7b6d809929f3689d18a68">&#9670;&nbsp;</a></span>apr_encode_base32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_encode_base32 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert text data to base32. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for encoding. </td></tr>
    <tr><td class="paramname">src</td><td>The original string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 32 Encoding. If APR_ENCODE_NOPADDING, omit the = padding character. If APR_ENCODE_BASE32HEX, use RFC4648 base32hex Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for encoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the encoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to encode. </dd></dl>

</div>
</div>
<a id="ga29f6e11140367fade452e64975f32f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29f6e11140367fade452e64975f32f07">&#9670;&nbsp;</a></span>apr_encode_base32_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_encode_base32_binary </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert binary data to base32. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for encoding. </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer, can be NULL if <code>dest</code> is NULL. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 32 Encoding. If APR_ENCODE_NOPADDING, omit the = padding character. If APR_ENCODE_BASE32HEX, use RFC4648 base32hex Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for encoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the encoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to encode. </dd></dl>

</div>
</div>
<a id="ga22d00775eef21b4d782a92b0bcf1e156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22d00775eef21b4d782a92b0bcf1e156">&#9670;&nbsp;</a></span>apr_encode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_encode_base64 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert text data to base64. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for encoding. </td></tr>
    <tr><td class="paramname">src</td><td>The original string, can be NULL if <code>dest</code> is NULL and <code>slen</code> is positive or nul. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 64 Encoding. If APR_ENCODE_NOPADDING, omit the = padding character. If APR_ENCODE_URL, use RFC4648 Base 64 Encoding with URL and Filename Safe Alphabet. If APR_ENCODE_BASE64URL, use RFC7515 base64url Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for encoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the encoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is not APR_ENCODE_STRING and negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to encode. </dd></dl>

</div>
</div>
<a id="gae1369e67e0d295a40f9d0c212fe5dafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1369e67e0d295a40f9d0c212fe5dafb">&#9670;&nbsp;</a></span>apr_encode_base64_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_encode_base64_binary </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert binary data to base64. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string, can be NULL to output in <code>len</code> the needed buffer length for encoding. </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer, can be NULL if <code>dest</code> is NULL. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 64 Encoding. If APR_ENCODE_NOPADDING, omit the = padding character. If APR_ENCODE_URL, use RFC4648 Base 64 Encoding with URL and Filename Safe Alphabet. If APR_ENCODE_BASE64URL, use RFC7515 base64url Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the buffer needed for encoding (including the trailing NUL) if <code>dest</code> is NULL, or the actual length of the encoding (excluding the trailing NUL) if <code>dest</code> is not NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_EINVAL if <code>slen</code> is negative, or APR_NOTFOUND if <code>dest</code> is not NULL and <code>src</code> is NULL, or APR_ENOSPC if <code>dest</code> is NULL and the source length (based on <code>slen</code> or APR_ENCODE_STRING) is too big to encode. </dd></dl>

</div>
</div>
<a id="ga6525de2c6a1398af18a918cfe686e401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6525de2c6a1398af18a918cfe686e401">&#9670;&nbsp;</a></span>apr_pdecode_base16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pdecode_base16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base16 (hex) and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The base16 string to decode. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, parse RFC4648 Base 16 Encoding. If APR_ENCODE_COLON, allow tokens to be separated with a colon. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the decoding is not possible (see apr_decode_base16 errors). </dd></dl>

</div>
</div>
<a id="gabf2388ef96733d95fd02b673bfe32d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf2388ef96733d95fd02b673bfe32d82">&#9670;&nbsp;</a></span>apr_pdecode_base16_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* apr_pdecode_base16_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base16 (hex) to binary data, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The base16 string to decode. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, parse RFC4648 Base 16 Encoding. If APR_ENCODE_COLON, allow tokens to be separated with a colon. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the decoding is not possible (see apr_decode_base16_binary errors). </dd></dl>

</div>
</div>
<a id="ga7de3aef884906d1c2b36449c48dab90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7de3aef884906d1c2b36449c48dab90e">&#9670;&nbsp;</a></span>apr_pdecode_base32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pdecode_base32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base32 or base32hex with or without padding to text data, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The base32 string to decode. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, parse RFC4648 Base 32 Encoding. If APR_ENCODE_BASE32HEX, use RFC4648 base32hex Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the decoding is not possible (see apr_decode_base32 errors). </dd></dl>

</div>
</div>
<a id="ga23ca695d97a11934e7fbc7c7f6dd8373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23ca695d97a11934e7fbc7c7f6dd8373">&#9670;&nbsp;</a></span>apr_pdecode_base32_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* apr_pdecode_base32_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base32 or base32hex with or without padding to binary data, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The base32 string to decode. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, parse RFC4648 Base 32 Encoding. If APR_ENCODE_BASE32HEX, use RFC4648 base32hex Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the decoding is not possible (see apr_decode_base32_binary errors). </dd></dl>

</div>
</div>
<a id="ga459a9a40c7bd9bba743ce0b3d456f18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga459a9a40c7bd9bba743ce0b3d456f18c">&#9670;&nbsp;</a></span>apr_pdecode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pdecode_base64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base64 or base64url with or without padding to text data, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The base64 string to decode. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, attempt to decode the full original buffer, and return NULL if any bad character is detected. If APR_ENCODE_RELAXED, decode until the first non base64/base64url character. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the decoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the decoding is not possible (see apr_decode_base64_binary errors). </dd></dl>

</div>
</div>
<a id="ga124935cfdf610e8f3cd0d43a91ff7254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga124935cfdf610e8f3cd0d43a91ff7254">&#9670;&nbsp;</a></span>apr_pdecode_base64_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* apr_pdecode_base64_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert base64 or base64url with or without padding to binary data, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The base64 string to decode. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, attempt to decode the full original buffer, and return NULL if any bad character is detected. If APR_ENCODE_RELAXED, decode until the first non base64/base64url character. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the decoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the decoding is not possible (see apr_decode_base64_binary errors). </dd></dl>

</div>
</div>
<a id="ga1eead158a297b072d956e79e4d33977f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eead158a297b072d956e79e4d33977f">&#9670;&nbsp;</a></span>apr_pencode_base16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pencode_base16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert text data to base16 (hex), and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The original string. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 16 Encoding. If APR_ENCODE_COLON, separate each token with a colon. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the encoding is not possible (see apr_encode_base16 errors). </dd></dl>

</div>
</div>
<a id="ga10ade6a0297757acd117fe20d0e8a4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10ade6a0297757acd117fe20d0e8a4a5">&#9670;&nbsp;</a></span>apr_pencode_base16_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pencode_base16_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert binary data to base16 (hex), and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 16 Encoding. If APR_ENCODE_COLON, separate each token with a colon. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the encoding is not possible (see apr_encode_base16_binary errors). </dd></dl>

</div>
</div>
<a id="ga8c2784fb3d74d2d82588b39c2b6a275a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c2784fb3d74d2d82588b39c2b6a275a">&#9670;&nbsp;</a></span>apr_pencode_base32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pencode_base32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert text data to base32, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The original string. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 32 Encoding. If APR_ENCODE_NOPADDING, omit the = padding character. If APR_ENCODE_BASE32HEX, use RFC4648 base32hex Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the encoding is not possible (see apr_encode_base32 errors). </dd></dl>

</div>
</div>
<a id="gac4780933a14779c4eb46e100b0c8e941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4780933a14779c4eb46e100b0c8e941">&#9670;&nbsp;</a></span>apr_pencode_base32_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pencode_base32_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert binary data to base32, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 32 Encoding. If APR_ENCODE_NOPADDING, omit the = padding character. If APR_ENCODE_BASE32HEX, use RFC4648 base32hex Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the encoding is not possible (see apr_encode_base32_binary errors). </dd></dl>

</div>
</div>
<a id="ga20cb2845739baa15c584977dfa58b154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20cb2845739baa15c584977dfa58b154">&#9670;&nbsp;</a></span>apr_pencode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pencode_base64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert text data to base64, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The original string. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ENCODE_STRING if the actual length should be computed based on NUL termination. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 64 Encoding. If APR_ENCODE_NOPADDING, omit the = padding character. If APR_ENCODE_URL, use RFC4648 Base 64 Encoding with URL and Filename Safe Alphabet. If APR_ENCODE_BASE64URL, use RFC7515 base64url Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the encoding is not possible (see apr_encode_base64 errors). </dd></dl>

</div>
</div>
<a id="gabfce66ef543bc712e59319c78b743f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfce66ef543bc712e59319c78b743f4f">&#9670;&nbsp;</a></span>apr_pencode_base64_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_pencode_base64_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_ssize_t&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert binary data to base64, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from. </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer. </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>If APR_ENCODE_NONE, emit RFC4648 Base 64 Encoding. If APR_ENCODE_NOPADDING, omit the = padding character. If APR_ENCODE_URL, use RFC4648 Base 64 Encoding with URL and Filename Safe Alphabet. If APR_ENCODE_BASE64URL, use RFC7515 base64url Encoding. </td></tr>
    <tr><td class="paramname">len</td><td>If not NULL, outputs the length of the encoding (excluding the trailing NUL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUL terminated string allocated from the pool on success, or NULL if src is NULL or allocation failed or the encoding is not possible (see apr_encode_base64_binary errors). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
